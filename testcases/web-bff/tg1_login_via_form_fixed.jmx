<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.6.3">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Gumtree Web Login API Test - Fixed">
      <stringProp name="TestPlan.comments">Test plan for Gumtree Web Login API - /bff-api/login/via-form (Fixed Version)</stringProp>
      <boolProp name="TestPlan.serialize_threadgroups">true</boolProp>
      <boolProp name="TestPlan.tearDown_on_shutdown">true</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
        <collectionProp name="Arguments.arguments"/>
      </elementProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
    </TestPlan>
    <hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="TG1: Web Login Scenarios">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="Web Login HTTP Header Manager" enabled="true">
          <collectionProp name="HeaderManager.headers">
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Content-Type</stringProp>
              <stringProp name="Header.value">${__P(CONTENT_TYPE)}</stringProp>
            </elementProp>
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">User-Agent</stringProp>
              <stringProp name="Header.value">${__P(USER_AGENT)}</stringProp>
            </elementProp>
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Accept</stringProp>
              <stringProp name="Header.value">${__P(ACCEPT)}</stringProp>
            </elementProp>
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Accept-Language</stringProp>
              <stringProp name="Header.value">${__P(ACCEPT_LANGUAGE)}</stringProp>
            </elementProp>
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Accept-Encoding</stringProp>
              <stringProp name="Header.value">${__P(ACCEPT_ENCODING)}</stringProp>
            </elementProp>
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Origin</stringProp>
              <stringProp name="Header.value">${__P(ORIGIN)}</stringProp>
            </elementProp>
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Referer</stringProp>
              <stringProp name="Header.value">${__P(REFERER)}</stringProp>
            </elementProp>
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Connection</stringProp>
              <stringProp name="Header.value">${__P(CONNECTION)}</stringProp>
            </elementProp>
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">sec-ch-ua</stringProp>
              <stringProp name="Header.value">${__P(SEC_CH_UA)}</stringProp>
            </elementProp>
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">sec-ch-ua-mobile</stringProp>
              <stringProp name="Header.value">${__P(SEC_CH_UA_MOBILE)}</stringProp>
            </elementProp>
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">sec-ch-ua-platform</stringProp>
              <stringProp name="Header.value">${__P(SEC_CH_UA_PLATFORM)}</stringProp>
            </elementProp>
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">sec-fetch-site</stringProp>
              <stringProp name="Header.value">${__P(SEC_FETCH_SITE)}</stringProp>
            </elementProp>
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">sec-fetch-mode</stringProp>
              <stringProp name="Header.value">${__P(SEC_FETCH_MODE)}</stringProp>
            </elementProp>
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">sec-fetch-dest</stringProp>
              <stringProp name="Header.value">${__P(SEC_FETCH_DEST)}</stringProp>
            </elementProp>
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Cache-Control</stringProp>
              <stringProp name="Header.value">${__P(CACHE_CONTROL)}</stringProp>
            </elementProp>
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Pragma</stringProp>
              <stringProp name="Header.value">${__P(PRAGMA)}</stringProp>
            </elementProp>
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Host</stringProp>
              <stringProp name="Header.value">${__P(HOST)}</stringProp>
            </elementProp>
          </collectionProp>
        </HeaderManager>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="1.1 Login - Correct Credentials">
          <stringProp name="TestPlan.comments">使用正确的用户名和密码登录</stringProp>
          <stringProp name="HTTPSampler.domain">${__P(HOST_BFF)}</stringProp>
          <stringProp name="HTTPSampler.protocol">${__P(PROTOCOL)}</stringProp>
          <stringProp name="HTTPSampler.path">${__P(LOGIN_PATH)}</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
            <collectionProp name="Arguments.arguments">
              <elementProp name="username" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${__P(CORRECT_USERNAME)}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">username</stringProp>
              </elementProp>
              <elementProp name="password" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${__P(CORRECT_PASSWORD)}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">password</stringProp>
              </elementProp>
              <elementProp name="legacy" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${__P(LEGACY_VALUE)}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">legacy</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="断言状态码 200" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">8</intProp>
            <stringProp name="Assertion.custom_message"></stringProp>
          </ResponseAssertion>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="断言响应包含 manage/ads">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="-1255755612">${__P(EXPECTED_REDIRECT_PATH)}</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
            <stringProp name="Assertion.custom_message">期望登录成功后重定向到 manage/ads 页面</stringProp>
          </ResponseAssertion>
          <hashTree/>
          <JSR223PostProcessor guiclass="TestBeanGUI" testclass="JSR223PostProcessor" testname="提取认证信息并保存到CSV - Fixed">
            <stringProp name="cacheKey">true</stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">import java.io.File
import java.io.FileWriter
import java.text.SimpleDateFormat
import groovy.json.JsonSlurper

log.info("=== 开始提取认证信息 ===")

// 获取当前时间戳
def timestamp = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS").format(new Date())

// 获取响应数据
def responseData = prev.getResponseDataAsString()
def responseHeaders = prev.getResponseHeaders()
def responseCode = prev.getResponseCode()
def responseTime = prev.getTime()

// 获取测试基本信息
def username = props.get("CORRECT_USERNAME") ?: "unknown"

// 初始化认证信息变量
def sessionId = "NO_SESSION_ID"
def rememberMe = "NO_REMEMBER_ME"
def gtMc = "NO_GT_MC"
def location = "NO_LOCATION"
def upstreamServiceTime = "NO_RESPONSE_TIME"
def userToken = "NO_USER_TOKEN"
def userAuthorization = "NO_USER_AUTHORIZATION"
def conversationsToken = "NO_CONVERSATIONS_TOKEN"
def csrfToken = "NO_CSRF_TOKEN"

// 初始化请求头信息变量
def userAgent = props.get("USER_AGENT") ?: "NO_USER_AGENT"
def acceptLanguage = props.get("ACCEPT_LANGUAGE") ?: "NO_ACCEPT_LANGUAGE"
def acceptEncoding = props.get("ACCEPT_ENCODING") ?: "NO_ACCEPT_ENCODING"
def secChUa = props.get("SEC_CH_UA") ?: "NO_SEC_CH_UA"
def secChUaMobile = props.get("SEC_CH_UA_MOBILE") ?: "NO_SEC_CH_UA_MOBILE"
def secChUaPlatform = props.get("SEC_CH_UA_PLATFORM") ?: "NO_SEC_CH_UA_PLATFORM"
def secFetchSite = props.get("SEC_FETCH_SITE") ?: "NO_SEC_FETCH_SITE"
def secFetchMode = props.get("SEC_FETCH_MODE") ?: "NO_SEC_FETCH_MODE"
def secFetchDest = props.get("SEC_FETCH_DEST") ?: "NO_SEC_FETCH_DEST"
def connection = props.get("CONNECTION") ?: "NO_CONNECTION"
def cacheControl = props.get("CACHE_CONTROL") ?: "NO_CACHE_CONTROL"
def pragma = props.get("PRAGMA") ?: "NO_PRAGMA"
def host = props.get("HOST") ?: "NO_HOST"

log.info("响应状态码: ${responseCode}")
log.info("响应时间: ${responseTime}ms")

// 1. 从响应头中提取信息
if (responseHeaders) {
    log.info("正在解析响应头...")
    
    // 提取Location头
    def locationMatch = responseHeaders =~ /(?i)Location:\s*(.+)/i
    if (locationMatch.find()) {
        location = locationMatch.group(1).trim()
        log.info("✓ 提取到Location: ${location}")
    }
    
    // 提取Set-Cookie头
    def setCookieHeaders = responseHeaders =~ /(?i)Set-Cookie:\s*(.+)/i
    if (setCookieHeaders.find()) {
        log.info("✓ 找到Set-Cookie头")
        setCookieHeaders.each { match ->
            def cookieLine = match.group(1).trim()
            log.info("  Set-Cookie: ${cookieLine}")
            
            // 提取GTSELLERSESSIONID
            if (cookieLine.contains("GTSELLERSESSIONID")) {
                def sessionMatch = cookieLine =~ /GTSELLERSESSIONID=([^;]+)/
                if (sessionMatch.find()) {
                    sessionId = sessionMatch.group(1).trim()
                    log.info("  ✓ 提取到SessionID: ${sessionId}")
                }
            }
            
            // 提取gt_rememberMe
            if (cookieLine.contains("gt_rememberMe")) {
                def rememberMatch = cookieLine =~ /gt_rememberMe=([^;]+)/
                if (rememberMatch.find()) {
                    rememberMe = rememberMatch.group(1).trim()
                    log.info("  ✓ 提取到RememberMe: ${rememberMe}")
                }
            }
            
            // 提取gt_mc
            if (cookieLine.contains("gt_mc")) {
                def gtMcMatch = cookieLine =~ /gt_mc=([^;]+)/
                if (gtMcMatch.find()) {
                    gtMc = gtMcMatch.group(1).trim()
                    log.info("  ✓ 提取到GT_MC: ${gtMc}")
                }
            }
            
            // 提取conversationsToken
            if (cookieLine.contains("conversationsToken")) {
                def convMatch = cookieLine =~ /conversationsToken=([^;]+)/
                if (convMatch.find()) {
                    conversationsToken = convMatch.group(1).trim()
                    log.info("  ✓ 提取到ConversationsToken: ${conversationsToken}")
                }
            }
            
            // 提取csrfToken
            if (cookieLine.contains("csrfToken")) {
                def csrfMatch = cookieLine =~ /csrfToken=([^;]+)/
                if (csrfMatch.find()) {
                    csrfToken = csrfMatch.group(1).trim()
                    userToken = csrfToken
                    log.info("  ✓ 提取到CSRF Token: ${csrfToken}")
                }
            }
        }
    }
    
    // 提取X-Envoy-Upstream-Service-Time
    def upstreamMatch = responseHeaders =~ /(?i)X-Envoy-Upstream-Service-Time:\s*(.+)/i
    if (upstreamMatch.find()) {
        upstreamServiceTime = upstreamMatch.group(1).trim()
        log.info("✓ 提取到Upstream Service Time: ${upstreamServiceTime}")
    }
}

// 2. 从响应体中提取信息
if (responseData && responseData.trim().startsWith("{")) {
    log.info("正在解析响应体JSON...")
    try {
        def json = new JsonSlurper().parseText(responseData)
        
        // 提取userToken
        if (json.userToken) {
            userToken = json.userToken.toString()
            log.info("✓ 从JSON提取到UserToken: ${userToken}")
        }
        
        // 提取userAuthorization
        if (json.userAuthorization) {
            userAuthorization = json.userAuthorization.toString()
            log.info("✓ 从JSON提取到UserAuthorization: ${userAuthorization}")
        }
        
        // 提取其他可能的字段
        if (json.token) {
            userToken = json.token.toString()
            log.info("✓ 从JSON提取到Token: ${userToken}")
        }
        
        if (json.accessToken) {
            userAuthorization = "Bearer " + json.accessToken.toString()
            log.info("✓ 从JSON提取到AccessToken: ${userAuthorization}")
        }
        
        if (json.csrfToken) {
            userToken = json.csrfToken.toString()
            csrfToken = userToken
            log.info("✓ 从JSON提取到CSRF Token: ${csrfToken}")
        }
        
        // 提取authorization token
        if (json.authorization) {
            userAuthorization = json.authorization.toString()
            log.info("✓ 从JSON提取到Authorization: ${userAuthorization}")
        }
        
        // 提取auth token
        if (json.auth) {
            userAuthorization = "Bearer " + json.auth.toString()
            log.info("✓ 从JSON提取到Auth Token: ${userAuthorization}")
        }
        
        // 如果没有Bearer前缀，自动添加
        if (userAuthorization != "NO_USER_AUTHORIZATION" && !userAuthorization.startsWith("Bearer ")) {
            userAuthorization = "Bearer " + userAuthorization
            log.info("✓ 自动添加Bearer前缀: ${userAuthorization}")
        }
        
    } catch (Exception e) {
        log.warn("⚠ 解析响应JSON时出错: ${e.message}")
    }
}

// 3. 构建完整的Cookie字符串
def cookieString = ""
if (sessionId != "NO_SESSION_ID") {
    cookieString += "GTSELLERSESSIONID=${sessionId}; "
}
if (rememberMe != "NO_REMEMBER_ME") {
    cookieString += "gt_rememberMe=${rememberMe}; "
}
if (gtMc != "NO_GT_MC") {
    cookieString += "gt_mc=${gtMc}; "
}
if (conversationsToken != "NO_CONVERSATIONS_TOKEN") {
    cookieString += "conversationsToken=${conversationsToken}; "
}
if (csrfToken != "NO_CSRF_TOKEN") {
    cookieString += "csrfToken=${csrfToken}; "
}
cookieString = cookieString.trim()

if (cookieString.isEmpty()) {
    cookieString = "NO_COOKIE_STRING"
}

// 4. 创建data目录
def dataDir = new File("data")
if (!dataDir.exists()) {
    dataDir.mkdirs()
}

// 5. CSV文件路径
def csvFile = new File(dataDir, "web_auth_tokens_fixed.csv")

try {
    // 直接覆盖文件，只保存最新数据
    def writer = new FileWriter(csvFile, false)
    
    // 写入表头
    writer.write("timestamp,username,statusCode,responseTime,sessionId,rememberMe,gtMc,location,upstreamServiceTime,userToken,userAuthorization,conversationsToken,cookieString,testResult,csrfToken,userAgent,acceptLanguage,acceptEncoding,secChUa,secChUaMobile,secChUaPlatform,secFetchSite,secFetchMode,secFetchDest,connection,cacheControl,pragma,host\n")
    
    // 写入最新数据行 - 使用CSV安全的方式
    def csvLine = [
        timestamp,
        username,
        responseCode,
        responseTime,
        sessionId,
        rememberMe,
        gtMc,
        location,
        upstreamServiceTime,
        userToken,
        userAuthorization,
        conversationsToken,
        cookieString,
        "SUCCESS",
        csrfToken,
        userAgent,
        acceptLanguage,
        acceptEncoding,
        secChUa,
        secChUaMobile,
        secChUaPlatform,
        secFetchSite,
        secFetchMode,
        secFetchDest,
        connection,
        cacheControl,
        pragma,
        host
    ]
    
    // 安全的CSV写入
    def csvData = csvLine.collect { field ->
        if (field && field.contains(",") || field.contains("\"") || field.contains("\n")) {
            "\"${field.replace("\"", "\"\"")}\""
        } else {
            field ?: ""
        }
    }.join(",")
    
    writer.write(csvData + "\n")
    writer.close()
    
    log.info("✓ 认证信息已保存到: ${csvFile.absolutePath}")
    
    // 将关键信息设置为JMeter变量，供后续测试使用
    vars.put("AUTH_SESSION_ID", sessionId)
    vars.put("AUTH_REMEMBER_ME", rememberMe)
    vars.put("AUTH_GT_MC", gtMc)
    vars.put("AUTH_COOKIE_STRING", cookieString)
    vars.put("AUTH_LOCATION", location)
    vars.put("AUTH_USER_TOKEN", userToken)
    vars.put("AUTH_USER_AUTHORIZATION", userAuthorization)
    vars.put("AUTH_CONVERSATIONS_TOKEN", conversationsToken)
    vars.put("AUTH_CSRF_TOKEN", csrfToken)
    
    // 检查是否成功提取到认证信息
    def hasValidAuth = false
    if (sessionId != "NO_SESSION_ID" || userToken != "NO_USER_TOKEN" || conversationsToken != "NO_CONVERSATIONS_TOKEN") {
        hasValidAuth = true
        log.info("✅ 成功提取到有效认证信息")
    } else {
        log.warn("⚠ 未提取到有效认证信息，可能需要检查响应格式")
    }
    
} catch (Exception e) {
    log.error("❌ 保存认证信息时出错: ${e.message}")
    prev.setSuccessful(false)
    prev.setResponseMessage("认证信息保存失败: ${e.message}")
}

log.info("=== 认证信息提取完成 ===")
log.info("SessionID: ${sessionId}")
log.info("RememberMe: ${rememberMe}")
log.info("GT_MC: ${gtMc}")
log.info("Location: ${location}")
log.info("UserToken: ${userToken}")
log.info("UserAuthorization: ${userAuthorization}")
log.info("ConversationsToken: ${conversationsToken}")
log.info("CSRFToken: ${csrfToken}")
log.info("Cookie字符串: ${cookieString}")
log.info("=== 请求头信息 ===")
log.info("User-Agent: ${userAgent}")
log.info("Accept-Language: ${acceptLanguage}")
log.info("Accept-Encoding: ${acceptEncoding}")
log.info("sec-ch-ua: ${secChUa}")
log.info("sec-ch-ua-mobile: ${secChUaMobile}")
log.info("sec-ch-ua-platform: ${secChUaPlatform}")
log.info("sec-fetch-site: ${secFetchSite}")
log.info("sec-fetch-mode: ${secFetchMode}")
log.info("sec-fetch-dest: ${secFetchDest}")
log.info("Connection: ${connection}")
log.info("Cache-Control: ${cacheControl}")
log.info("Pragma: ${pragma}")
log.info("Host: ${host}")









